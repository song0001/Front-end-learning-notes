# 此面试题为个人经验总结

### 1.get和post请求的区别

- get : 能够缓存、不安全、请求长度受限不能超过4k、会被历史保存记录
- post: 不会缓存、安全、请求数据大小不受限、更多编码类型 

###  2.闭包

-  闭包是指有权访问另一个函数作用域中的变量的函数 

-  作用：1.使用闭包可以访问函数中的变量。2.可以使变量长期保存在内存中，生命周期比较长。
-  缺点：闭包不能滥用，否则会导致内存泄露，影响网页的性能。
-  应用场景：1.函数作为参数传递。2.函数作为返回值

###  3.防抖与节流

 防抖与节流函数是一种最常用的 高频触发**优化方式**，能对性能有较大的帮助。 

- 防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。

- 节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。

### 4.常见状态码

- 1xx: 接受，继续处理
- 200: 成功，并返回数据
- 301: 永久移动，重定向
- 304: 资源未修改，可使用缓存
- 305: 需代理访问
- 400: 请求语法错误
- 401: 要求身份认证
- 403: 拒绝请求
- 404: 资源不存在
- 500: 服务器错误

### 5.Websocket

> 概念：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。它是一个 持久化的协议， 基于 http ， 服务端可以 主动 push

### 6. Promise

> 概念： Promise 是异步编程的一种解决方案，能够一定程度上解决传统请求ajax如果进行嵌套造成的回调地狱问题

### 7. 跨域

> 概念：跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略（域名、协议、端口均为相同）造成的，是浏览器对JavaScript实施的安全限制。

**解决方式**

- JSONP: 主要是操作dom，在vue和react中一般不用，利用script标签不受跨域限制的特点，缺点是只能支持 get 请求。

- 设置 CORS: Access-Control-Allow-Origin：*，后台来进行设置，一般是在线上环境的时候解决跨域问题的方式

- 通过Node启动一个服务转发请求，因为服务端没有跨域限制

- 在vue和react中通过配置webpack的proxy来处理

### 8. 浏览器存储Cookie、 LocalStorage 与 SessionStorage

Cookie：

- 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效
- 大小限制为4KB左右
- 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
- 需要程序员自己封装，源生的Cookie接口不友好

LocalStorage：

- 除非被清除，否则永久保存
- 一般为5MB
- 仅在客户端（即浏览器）中保存，不参与和服务器的通信
- 原生接口可以接受，亦可再次封装来对Object和Array有更好的支持

SessionStorage：

- 仅在当前会话下有效，关闭页面或浏览器后被清除
- 一般为5MB
- 仅在客户端（即浏览器）中保存，不参与和服务器的通信
- 原生接口可以接受，亦可再次封装来对Object和Array有更好的支持

### 9.环境和作用域

全局环境不会被回收，因为有可能在控制台所使用

写在函数内，不可访问到，而且没有其他地方引用他们的话，当函数执行完，他们都会被回收。

函数作用域在调用完函数后且没有其他引用时就会销毁，下次再调用就是新开辟一个作用域。

### 10.http和https区别

- **HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。**
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

### 11.vue页面的生命周期？

  总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

创建前/后： 在**beforeCreate**阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在**created**阶段，vue实例的数据对象data有了，$el还没有。

载入前/后：在**beforeMount**阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在**mounted**阶段，vue实例挂载完成，data.message成功渲染。

更新前/后：当data变化时，会触发**beforeUpdate**和**updated**方法。

销毁前/后：**beforeDestroy**在执行**destroyed**方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

### 12.Vue2.x组件通信有哪些方式

- 父子组件通信: props 、$on、$emit、 Ref 获取实例的方式调用组件的属性或者方法、（Provide、inject 官方不推荐使用，但是写组件库时很常用）

- 兄弟组件通信: EventBus 、Vuex

- 跨级组件通信：Vuex、$attrs、$listeners、Provide、（Provide、inject 官方不推荐使用，但是写组件库时很常用）

  ## 13.vuex是什么呢？哪些场景会用到？

  vuex是一个专为vue.js应用程序开发的状态管理模式

  我们大概可以理解为vuex是一个公共 状态库 , 你可以在所有的组件里面去使用,修改

  场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车

  

  vuex为状态管理，它集中存储管理应用的所有组件的状态，可以理解成一个全局仓库

  VueRouter是路由（spa）单页面应用的方式

### 14.vuex的state、getter、mutation、action、module特性分别是什么？

**State:** 保存着所有的全局变量

**Getter**: store中的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。  getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略。

**Mutation:** 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation, mutation 必须是同步函数

**Action:** Action 可以包含任意异步操作, 在组件中使用 this.$store.dispatch(‘xxx’) 分发 action

**Module:** 可以写很多模块，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters，最后都引入到一个文件。分散管理。

### 15.路由跳转传参两种方式

传参可以使用params和query两种方式。
使用params传参只能用name来引入路由，即push里面只能是name:’xxxx’,不能是path:’/xxx’,因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined！！！。
使用query传参使用path来引入路由。
params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。
二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示。

### 16.$nextTick

$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。

### 17.es6新特性

1.变量声明const和let
2.模板对象与模板字符串
3.箭头函数
4.class类的支持

5.Symbol :表示独一无 二的值，Symbol最大的用途是用来定义对象的唯一属性名。

6.map和set

7.promise

8.async/await

### 18.promise原理

#### promise是什么？

1、主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
3、可以在对象之间传递和操作promise，帮助我们处理队列

#### 原理:

1、解决回调地狱
      比如我们经常可能需要异步请求一个数据之后作为下一个异步操作的入参

2、promise 可以实现在多个请求发送完成后 再得到或者处理某个结果

#### 最简单的实现

 基于上面的应用场景发现`promise`可以有三种状态，分别是`pending` 、`Fulfilled`、 `Rejected`。

>  `Pending Promise`对象实例创建时候的初始状态
>  `Fulfilled` 可以理解为成功的状态
>  `Rejected`可以理解为失败的状态

-  给`Promise`构造函数传入一个函数。传入的函数需要有两个形参，两个形参都是`function`类型的参数。分别是`resolve`和`reject`。
- `Promise`上还有`then`方法，`then` 方法就是用来指定`Promise` 对象的状态改变时确定执行的操作，`resolve` 时执行第一个函数（onFulfilled），`reject`时执行第二个函数（onRejected）
- 当状态变为`resolve`时便不能再变为`reject`，反之同理。

### 19.position 

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| fixed    | 生成固定定位的元素，相对于浏览器窗口进行定位。（老IE不支持）元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| relative | 生成相对定位的元素，相对于其正常位置进行定位，不脱离文档流。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。 |
| static   | 默认值。没有定位，元素出现在正常的文档流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |
| inherit  | 规定应该从父元素继承 position 属性的值。                     |

css 定位还有一个新增属性，**粘性定位 sticky**，它主要用在对 scroll 事件的监听上；

粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。例如：

```
#one { position: sticky; top: 10px; }复制代码
```

在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下

### 20.用纯CSS创建一个三角形

首先，需要把元素的宽度、高度设为0。然后设置边框样式。

```
width: 0;
height: 0;
border-top: 40px solid transparent;
border-left: 40px solid transparent;
border-right: 40px solid transparent;
border-bottom: 40px solid #ff0000;复制代码
```

### 21.关于优化

#### 网站性能优化

   1、http请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的dns解析在2到4个域名，提取公告的样式，公共的组件，雪碧图，缓存资源，

   2、压缩资源，提取公共资源压缩，提取css ,js公共方法

   3、不要缩放图片，使用雪碧图，使用字体图表(阿里矢量图库)

   4、使用CDN，抛开无用的cookie

   5、减少重绘重排，CSS属性读写分离，最好不要用js修改样式，dom 离线更新，渲染前指定,图片的大小

   6、js代码层面的优化，减少对字符串的计算,合理使用闭包，首屏的js资源加载放在最底部  

#### 项目优化

##### 1、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

##### 2、v-if 和 v-show 区分使用场景

v-if是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

**v-show**就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。

所以，*v-if* 适用于在运行时很少改变条件，不需要频繁切换条件的场景；*v-show*则适用于需要非常频繁切换条件的场景。

##### 3、computed 和 watch 区分使用场景

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作

##### 4、长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

##### 5、图片资源懒加载：Vue 的 vue-lazyload 插件

##### 6、路由懒加载

##### 7、第三方插件的按需引入；

react路由懒加载是loadable插件

#### web项目性能优化

1、压缩源码和图片
JavaScript文件源代码可以采用混淆压缩的方式，CSS文件源代码进行普通压缩，JPG图片可以根据具体质量来压缩为50%到70%，PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等。

2、选择合适的图片格式
如果图片颜色数较多就使用JPG格式，如果图片颜色数较少就使用PNG格式，如果能够通过服务器端判断浏览器支持WebP，那么就使用WebP格式和SVG格式。

3、合并静态资源
包括CSS、JavaScript和小图片，减少HTTP请求。有很大一部分用户访问会因为这一条而取得最大受益

4、开启服务器端的Gzip压缩
这对文本资源非常有效，对图片资源则没那么大的压缩比率。

5、使用CDN
或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize.css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存。

6、延长静态资源缓存时间
这样，频繁访问网站的访客就能够更快地访问。不过，这里要通过修改文件名的方式，确保在资源更新的时候，用户会拉取到最新的内容。

7、把CSS放在页面头部，把JavaScript放在页面底部
这样就不会阻塞页面渲染，让页面出现长时间的空白。

#### 性能优化

- 编码阶段

> 1. 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
> 2. v-if和v-for不能连用
> 3. 如果需要使用v-for给每项元素绑定事件时使用事件代理
> 4. SPA 页面采用keep-alive缓存组件
> 5. 在更多的情况下，使用v-if替代v-show
> 6. key保证唯一
> 7. 使用路由懒加载、异步组件
> 8. 防抖、节流
> 9. 第三方模块按需导入
> 10. 长列表滚动到可视区域动态加载
> 11. 图片懒加载

- SEO优化

> 1. 预渲染
> 2. 服务端渲染SSR

- 打包优化

> 1. 压缩代码
> 2. Tree Shaking/Scope Hoisting
> 3. 使用cdn加载第三方模块
> 4. 多线程打包happypack----不常用
> 5. splitChunks抽离公共文件
> 6. sourceMap优化

- 用户体验

> 1. 骨架屏
> 2. PWA---不常用
> 3. 客户端缓存、服务端缓存

### 22.小程序生命周期

1. onLoad 监听页面加载，一个页面只会调用一次
2. onShow 监听页面显示，每次打开页面都会调用
3. onReady 监听页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互
4. onHide 监听页面隐藏
5. onUnload 监听页面卸载

### 23.flex布局

- flex-direction
- flex-wrap
- flex-flow
- justify-content
- align-items
- align-content

### 24.什么情况不建议使用箭头函数

定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。

### 25.小程序页面跳转api

####  navigateTo跳转非tabBar页面

保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html) 可以返回到原页面。小程序中页面栈最多十层。

```
 wx.navigateTo({

   url:"/pages/info/info"

  })
```

#### switchTab跳转到tab页面 

跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面

```
 wx.switchTab({

   url:"/pages/test/test"

  })
```

#### relanch跳转页面 

关闭所有页面，打开到应用内的某个页面

```
 wx.reLaunch({

   url: '/pages/info/info',

  })
```

#### redirectTo跳转页面 



关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。

```
 wx.redirectTo({

   url: '/pages/info/info',

  })
```

#### navigateBack后退  

```
 wx.navigateBack({

   url: '/pages/info/info',

  })
```

### 26.cookie字段

**name**字段 为一个cookie的名称。

**value**字段 为一个cookie的值。

**domain**字段 为可以访问此cookie的域名。

**path**字段 为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。

**expires/Max-Age**字段 为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。

**Size**字段  此cookie大小。

**http**字段  cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。

**secure** 字段 设置是否只能通过https来传递此条cookie

### 27.vue父子组件的生命周期

- 加载渲染过程

  ```
  父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
  复制代码
  ```

- 子组件更新过程

  ```
  父beforeUpdate->子beforeUpdate->子updated->父updated
  复制代码
  ```

- 父组件更新过程

  ```
  父beforeUpdate->父updated
  复制代码
  ```

- 销毁过程

  ```
  父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
  ```

### 28.对象的解构赋值

```
   let node = {
            type: {
                a: 5,
                b: 10
            },
            name: "foo"
        };
        let {
            a,
            b
        } = node.type
        console.log(a); //5
        console.log(b); //10
```

### 29. Ajax的原理

简单来说就是 通过创建XmlHttpRequest对象向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作DOM更新页面的技术。

```
//get请求方式
function get(url, fn){
        var xhr=new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.onreadystatechange=function(){
            if(xhr.readyState === 4){
                if(xhr.status === 200){
                    fn.call(xhr.responseText);
                }
            }
        }
        xhr.send();
    }

//post请求方式
function post(url, data, fn){
        var xhr=new XMLHttpRequest();
        xhr.open('POST', url, false);
        // 添加http头，发送信息至服务器时内容编码类型
        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
        xhr.onreadystatechange=function(){
            if (xhr.readyState === 4){
                if (xhr.status === 200){
                    fn.call(xhr.responseText);
                }
            }
        }
        xhr.send(data);
    }
```

### 30.事件委托

事件委托，一般来说，会把一个或一组元素的时间委托到它的父元素上或者更外层元素上，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。在一些场景下，可以让性能得到优化。 比如给所有的列表添加点击事件，如果采用冒泡流，那么我们需要给每个元素添加点击事件，而采用事件委托的话，只需要在ul上绑定一个事件即可。